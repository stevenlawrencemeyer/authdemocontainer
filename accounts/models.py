from django.db import models
from django.contrib.auth.models import AbstractUser, BaseUserManager
from django.core.validators import (RegexValidator, EmailValidator)
from django.conf import settings
from django.db.models.signals import post_save
from django.urls import reverse



#This is used in validation of display username
USERNAME_REGEX = '^[a-zA-Z0-9. _-]*$'
err_msg1 = 'Username can only contain letters, numbers, hyphens '
err_msg1+= ' underscores and spaces'
#This is used in validation of first_name, mid_initials & last_name
#NAME_REGEX = '^[a-zA-Z \-]*$'
NAME_REGEX = '^[- \w+]*$'



#Django documentation recommends making a subclass from
#AbstractBaseUser. See:

#https://docs.djangoproject.com/en/2.1/topics/auth/customizing/

#I found it easier to subclass AbstractUser, mainly because it has
#a good manager. If you subclass AbstractBaseUser you will have
#to write a custom manager

#I called our custom user a "member" because I wanted a name that
#could not be confused with the default "user" in Django

#My philosophy is a minimalist User model with an attached User Profile

#In general the User details are visible only to the User with the
#exception of "display_username" (see below)

#The profile contains information the User wants to make available
#to the general public

class Member(AbstractUser):
	
	email = models.EmailField(max_length=100, unique=True,
	    verbose_name='Email address')
	    
	#allow an optional alterantive email
	alt_email = models.EmailField(max_length=100, unique=True,
	    blank=True, null=True,
		verbose_name='Alt Email address')
		
	#We use Javascript and Ajax to enure that all email
	#Addresses are unique. So an alternate email address for 
	#one user cannot equal the primary email address for 
	#another user.
	#We could use the same method to ensure that, eg, all mobile
	#phone numbers are unique
	
	
	
	#User can reset this from False to True
	use_alt_email = models.BooleanField(default=False)


	#The "display_username" is the name visible to the user
	#and the public. When a form is rendered it has label Username
	#So far as user is concerned this is his/her username
	
	display_username = models.CharField(max_length=100,
	    unique=True,
	    validators = [
	        RegexValidator(
	            regex=USERNAME_REGEX,
	            message=err_msg1,
	            code='invalid_display_username',
	        )
	    ]
	)
	
	#This is the "real" username used by the Django authentication
	#system. It is generated by the system and kept secret from
	#both the user and the public
	#I call this the SYNTHETIC USERNAME 
	
	username = models.CharField(max_length=255, unique=True)
	
	#for use in later development
	slug = models.SlugField(max_length=255, unique=True)
	
	first_name = models.CharField(max_length=120,
	    blank=True, null=True,
	    validators = [
	        RegexValidator(
	            regex=NAME_REGEX,
	            message='Name is alpha only',
	            code='invalid_first_name',
	        )
	    ]
	)
	    
	mid_initials = models.CharField(max_length=20,
	    blank=True, null=True,
	    validators = [
	        RegexValidator(
	            regex=NAME_REGEX,
	            message='Name is alpha only',
	            code='invalid_mid_initials',
	        )
	    ]
	)
	
	last_name = models.CharField(max_length=120,
	    blank=True, null=True,
	    validators = [
	        RegexValidator(
	            regex=NAME_REGEX,
	            message='Name is alpha only',
	            code='invalid_last_name',
	        )
	    ]
	)
#The default is "is_active=True" which is fine where we do not
#require an authentication email
#
#But see RegisterView where we change the is_active field to
#False until we receive member confirmation. Then in ActivateView 
#we change is_active back to True.
  	
	is_active = models.BooleanField(default=True)
	is_admin = models.BooleanField(default=False)
	is_staff = models.BooleanField(default=False)
	
	create_dt = models.DateTimeField(auto_now_add=True)
	update_dt = models.DateTimeField(auto_now=True)


	# Here we tell Django the USERNAME_FIELD is username
	# If we wanted to login with, say, email address we would
	# Have 
	# USERNAME_FIELD = 'email'
	# In fact we allow login with either display_username
	# or primary email. How this is achieved we shall see
	# When we look at views

	USERNAME_FIELD = 'username'

		
	def __str__(self):
		return self.username
	
	def get_absolute_url(self, *args, **kwargs):
		url = reverse('accounts:member_detail',
		    args = [self.pk,])
		return url

# DO WE NEED TO DO ALL THIS? WHY NOT USE THE DJANGO DEFAULT USER?
# Django default user has five fields:
# (1)  username (This is the default login identifier)
# (2)  password
# (3)  email address
# (4)  first name
# (5)  last name
# We could do the following:
# (1)  Do not display username in the regisgtration form
# (2)  Label first name as username. This will be the 
#      the equivalent of display username
# (3)  Label last name as Alternate email address in forms
# (4)  Generate a synthetic username
# (5)  Move users first name, last name and middle initials to
#      the profile record
# But once we know how to do an abstraction it provides more 
# flexibility. We may add more fields such as mobile phone number
# or secret questions (What is you husband's mother's middle name)

#PROFILE
#One of these is created every time a new user is registered
#See signals below
#Profile is in a one to one relationship with Member

class Profile(models.Model):
	
	user = models.OneToOneField(settings.AUTH_USER_MODEL,
	    on_delete= models.CASCADE)
	    
	city = models.CharField(max_length = 100, null=True, blank=True)
	country = models.CharField(max_length=100, null=True, blank=True)
	about = models.CharField(max_length=5000, null=True, blank=True)
	website = models.URLField(max_length=120, null=True, blank=True)
	
	# This is why we needed to install pillow
	profile_pic = models.ImageField(upload_to='profilepix/', blank=True,
	null=True)
	
	pic_caption = models.CharField(max_length=200, blank=True, 
	    null=True, default='')
	
	create_dt = models.DateTimeField(auto_now_add=True)
	update_dt = models.DateTimeField(auto_now=True)

	def __str__(self):
		return self.user.email
		
	def get_absolute_url(self):
		url = reverse('accounts:profile_detail',
		    args=[self.pk])
		return url
		
	def get_field_values(self):
		z = [field.value_to_string(self) for field in Profile._meta.fields]
		return z
		

		
		
#This signal creates a profile every time a new user is registered
#Instead of generating a skeletal profile record we could just
#set up a profile creation form. I personally do not like the use
#of signals.

		
#This is the receiver
def post_save_user_model_receiver(sender, instance, created, *args, **kwargs):
	if created:  #if user model has been created (not profile)
		try:
			Profile.objects.create(user=instance)  #if profile already exists make exception
		except:
			pass
			
#The sender is the AUTH_USER_MODEL which, in our case, is accounts.member
#it sends the signal every time a new user is created (saved) on the database 
post_save.connect(post_save_user_model_receiver, sender=settings.AUTH_USER_MODEL)

# I do  not like signals
# I really, REALLY REEEAAALY do not like signals
# Use them as a last resort when all else fails
# Uncrossing crossed signals is a nightmare
# Just use a profile creation form to create profiles
# Put mandatory fields in the user creation form







